<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AVR32 UC3 - Power Manager Driver Example 2: pm.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>pm.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Power Manager driver. 
<p>
<ul>
<li>Compiler: IAR EWAVR32 and GNU GCC for AVR32</li><li>Supported devices: All AVR32 devices.</li><li>AppNote:</li></ul>
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <br>
 Support and FAQ: <a href="http://support.atmel.no/">http://support.atmel.no/</a> </dd></dl>

<p>
Definition in file <a class="el" href="a00019.html">pm.h</a>.
<p>
<code>#include &lt;avr32/io.h&gt;</code><br>
<code>#include &quot;compiler.h&quot;</code><br>
<code>#include &quot;preprocessor.h&quot;</code><br>

<p>
<a href="a00019.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a002dbb0ee44700b14048e2ef609941c">SLEEP</a>(mode)&nbsp;&nbsp;&nbsp;{__asm__ __volatile__ (&quot;sleep &quot;STRINGZ(mode));}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the MCU in the specified sleep mode.  <a href="#a002dbb0ee44700b14048e2ef609941c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#8228de41932fd29324b2d9dc95d45b7c">pm_cksel</a> (volatile avr32_pm_t *pm, unsigned int pbadiv, unsigned int pbasel, unsigned int pbbdiv, unsigned int pbbsel, unsigned int hsbdiv, unsigned int hsbsel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will select all the power manager clocks.  <a href="#8228de41932fd29324b2d9dc95d45b7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#d55486a0d6a70c24b71daaabee51e551">pm_disable_clk0</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will disable the oscillator 0.  <a href="#d55486a0d6a70c24b71daaabee51e551"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#4b72ef7f6a4157966efd67fedc41babd">pm_disable_clk1</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will disable the oscillator 1.  <a href="#4b72ef7f6a4157966efd67fedc41babd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#362f6f7ba31e41788ea867d9271d1411">pm_disable_clk32</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will disable the oscillator 32.  <a href="#362f6f7ba31e41788ea867d9271d1411"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#5025d406938e948be1a321bb0a3de34e">pm_enable_clk0</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the oscillator 0 to be used with a startup time.  <a href="#5025d406938e948be1a321bb0a3de34e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#b50c60c1a2fcafcbdbc395737bce49ae">pm_enable_clk0_no_wait</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the oscillator 0 to be used with no startup time.  <a href="#b50c60c1a2fcafcbdbc395737bce49ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#11e96570c59c9b54e612141bad5c9c6f">pm_enable_clk1</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the oscillator 1 to be used with a startup time.  <a href="#11e96570c59c9b54e612141bad5c9c6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#3c97a98610de7191421594f7f2407b71">pm_enable_clk1_no_wait</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the oscillator 1 to be used with no startup time.  <a href="#3c97a98610de7191421594f7f2407b71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#977a1c67c15cb6590bdd07ffc382be69">pm_enable_clk32</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the oscillator 32 to be used with a startup time.  <a href="#977a1c67c15cb6590bdd07ffc382be69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#b4b3927822c15f8df87264dc234d2c09">pm_enable_clk32_no_wait</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the oscillator 32 to be used with no startup time.  <a href="#b4b3927822c15f8df87264dc234d2c09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#154f6db98bf919e5065c47a9454ea31b">pm_enable_osc0_crystal</a> (volatile avr32_pm_t *pm, unsigned int fosc0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the crystal mode of the oscillator 0.  <a href="#154f6db98bf919e5065c47a9454ea31b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#71457d17efdbadb3f1beddd489b20642">pm_enable_osc0_ext_clock</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the external clock mode of the oscillator 0.  <a href="#71457d17efdbadb3f1beddd489b20642"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#55b91688c1de5c7ba887ae2c2da65c1a">pm_enable_osc1_crystal</a> (volatile avr32_pm_t *pm, unsigned int fosc1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the crystal mode of the oscillator 1.  <a href="#55b91688c1de5c7ba887ae2c2da65c1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ad913774e66e6728567fda276b16d7e5">pm_enable_osc1_ext_clock</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the external clock mode of the oscillator 1.  <a href="#ad913774e66e6728567fda276b16d7e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#afccfc12464e07508a75b0e9f09e125b">pm_enable_osc32_crystal</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the crystal mode of the 32-kHz oscillator.  <a href="#afccfc12464e07508a75b0e9f09e125b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#9345492d2ae11c99ef58fdeaa239b86a">pm_enable_osc32_ext_clock</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable the external clock mode of the 32-kHz oscillator.  <a href="#9345492d2ae11c99ef58fdeaa239b86a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#219014f9e640b87762b1edccb0f122a8">pm_gc_disable</a> (volatile avr32_pm_t *pm, unsigned int gc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will disable a generic clock.  <a href="#219014f9e640b87762b1edccb0f122a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#f398f0b8b8c3ff5649d3d86d7591f349">pm_gc_enable</a> (volatile avr32_pm_t *pm, unsigned int gc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable a generic clock.  <a href="#f398f0b8b8c3ff5649d3d86d7591f349"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#18f43cfefefcc5ef47b1d6b7318184ea">pm_gc_setup</a> (volatile avr32_pm_t *pm, unsigned int gc, unsigned int osc_or_pll, unsigned int pll_osc, unsigned int diven, unsigned int div)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will setup a generic clock.  <a href="#18f43cfefefcc5ef47b1d6b7318184ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__inline__ unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#950f26885a5ac10270176cbe10ab68d5">pm_get_reset_cause</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the MCU reset cause.  <a href="#950f26885a5ac10270176cbe10ab68d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#e403f725dd02b4a0edabf8c5f4069abf">pm_pll_disable</a> (volatile avr32_pm_t *pm, unsigned int pll)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will disable a PLL.  <a href="#e403f725dd02b4a0edabf8c5f4069abf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#8a475c167a147ef710e63eb7074febc5">pm_pll_enable</a> (volatile avr32_pm_t *pm, unsigned int pll)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will enable a PLL.  <a href="#8a475c167a147ef710e63eb7074febc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#dd1529c5261abd21d936126ca87fc804">pm_pll_get_option</a> (volatile avr32_pm_t *pm, unsigned int pll)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will get a PLL option.  <a href="#dd1529c5261abd21d936126ca87fc804"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#e3c68fa61aae34b1b4e064f2efd19ab8">pm_pll_set_option</a> (volatile avr32_pm_t *pm, unsigned int pll, unsigned int pll_freq, unsigned int pll_div2, unsigned int pll_wbwdisable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will set a PLL option.  <a href="#e3c68fa61aae34b1b4e064f2efd19ab8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#356dd97babbdf250ea51ccaa84992cf9">pm_pll_setup</a> (volatile avr32_pm_t *pm, unsigned int pll, unsigned int mul, unsigned int div, unsigned int osc, unsigned int lockcount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will setup a PLL.  <a href="#356dd97babbdf250ea51ccaa84992cf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ff34f78cd2e886452e22b0dd81f80fee">pm_switch_to_clock</a> (volatile avr32_pm_t *pm, unsigned long clock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will switch the power manager main clock.  <a href="#ff34f78cd2e886452e22b0dd81f80fee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#3248d4f14f43849e01bca054da9fdb1e">pm_switch_to_osc0</a> (volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch main clock to clock Osc0 (crystal mode).  <a href="#3248d4f14f43849e01bca054da9fdb1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#8d73b00aa88012b6230f2929b4b62c20">pm_wait_for_clk0_ready</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will wait until the Osc0 clock is ready.  <a href="#8d73b00aa88012b6230f2929b4b62c20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#d5ba9c5ac6eddbaa3ae1e2fda64b82f2">pm_wait_for_clk1_ready</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will wait until the Osc1 clock is ready.  <a href="#d5ba9c5ac6eddbaa3ae1e2fda64b82f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#9700519e5fc96b6cbb4d4e74d710cf49">pm_wait_for_clk32_ready</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will wait until the osc32 clock is ready.  <a href="#9700519e5fc96b6cbb4d4e74d710cf49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#5cd1af7daf6f927465ce522b29265225">pm_wait_for_pll0_locked</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will wait for PLL0 locked.  <a href="#5cd1af7daf6f927465ce522b29265225"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#9ae711c886d0b25bdb52e829975a6d6e">pm_wait_for_pll1_locked</a> (volatile avr32_pm_t *pm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will wait for PLL1 locked.  <a href="#9ae711c886d0b25bdb52e829975a6d6e"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a002dbb0ee44700b14048e2ef609941c"></a><!-- doxytag: member="pm.h::SLEEP" ref="a002dbb0ee44700b14048e2ef609941c" args="(mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SLEEP          </td>
          <td>(</td>
          <td class="paramtype">mode&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;{__asm__ __volatile__ (&quot;sleep &quot;STRINGZ(mode));}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the MCU in the specified sleep mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Sleep mode: <ul>
<li><code>AVR32_PM_SMODE_IDLE:</code> Idle; </li>
<li><code>AVR32_PM_SMODE_FROZEN:</code> Frozen; </li>
<li><code>AVR32_PM_SMODE_STANDBY:</code> Standby; </li>
<li><code>AVR32_PM_SMODE_STOP:</code> Stop; </li>
<li><code>AVR32_PM_SMODE_SHUTDOWN:</code> Shutdown (DeepStop); </li>
<li><code>AVR32_PM_SMODE_STATIC:</code> Static. </li>
</ul>
</td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00019.html#l00062">62</a> of file <a class="el" href="a00019.html">pm.h</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="8228de41932fd29324b2d9dc95d45b7c"></a><!-- doxytag: member="pm.h::pm_cksel" ref="8228de41932fd29324b2d9dc95d45b7c" args="(volatile avr32_pm_t *pm, unsigned int pbadiv, unsigned int pbasel, unsigned int pbbdiv, unsigned int pbbsel, unsigned int hsbdiv, unsigned int hsbsel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_cksel           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pbadiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pbasel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pbbdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pbbsel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>hsbdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>hsbsel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will select all the power manager clocks. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pbadiv</em>&nbsp;</td><td>Peripheral Bus A clock divisor enable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pbasel</em>&nbsp;</td><td>Peripheral Bus A select </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pbbdiv</em>&nbsp;</td><td>Peripheral Bus B clock divisor enable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pbbsel</em>&nbsp;</td><td>Peripheral Bus B select </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hsbdiv</em>&nbsp;</td><td>High Speed Bus clock divisor enable (CPU clock = HSB clock) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hsbsel</em>&nbsp;</td><td>High Speed Bus select (CPU clock = HSB clock ) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00319">319</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00059">u_avr32_pm_cksel_t::cksel</a>, and <a class="el" href="a00018.html#l00060">u_avr32_pm_cksel_t::CKSEL</a>.
<p>
Referenced by <a class="el" href="a00020.html#l00106">local_start_pll0()</a>.<div class="fragment"><pre class="fragment"><a name="l00326"></a>00326 {
<a name="l00327"></a>00327   <a class="code" href="a00003.html">u_avr32_pm_cksel_t</a> u_avr32_pm_cksel = {0};
<a name="l00328"></a>00328 
<a name="l00329"></a>00329   u_avr32_pm_cksel.<a class="code" href="a00003.html#a5476d04f93137f4269ea7de7d664d92">CKSEL</a>.cpusel = hsbsel;
<a name="l00330"></a>00330   u_avr32_pm_cksel.<a class="code" href="a00003.html#a5476d04f93137f4269ea7de7d664d92">CKSEL</a>.cpudiv = hsbdiv;
<a name="l00331"></a>00331   u_avr32_pm_cksel.<a class="code" href="a00003.html#a5476d04f93137f4269ea7de7d664d92">CKSEL</a>.hsbsel = hsbsel;
<a name="l00332"></a>00332   u_avr32_pm_cksel.<a class="code" href="a00003.html#a5476d04f93137f4269ea7de7d664d92">CKSEL</a>.hsbdiv = hsbdiv;
<a name="l00333"></a>00333   u_avr32_pm_cksel.<a class="code" href="a00003.html#a5476d04f93137f4269ea7de7d664d92">CKSEL</a>.pbasel = pbasel;
<a name="l00334"></a>00334   u_avr32_pm_cksel.<a class="code" href="a00003.html#a5476d04f93137f4269ea7de7d664d92">CKSEL</a>.pbadiv = pbadiv;
<a name="l00335"></a>00335   u_avr32_pm_cksel.<a class="code" href="a00003.html#a5476d04f93137f4269ea7de7d664d92">CKSEL</a>.pbbsel = pbbsel;
<a name="l00336"></a>00336   u_avr32_pm_cksel.<a class="code" href="a00003.html#a5476d04f93137f4269ea7de7d664d92">CKSEL</a>.pbbdiv = pbbdiv;
<a name="l00337"></a>00337 
<a name="l00338"></a>00338   pm-&gt;cksel = u_avr32_pm_cksel.<a class="code" href="a00003.html#fb7d76d8d2d67d485d8db54f8b2c5408">cksel</a>;
<a name="l00339"></a>00339 
<a name="l00340"></a>00340   <span class="comment">// Wait for ckrdy bit and then clear it</span>
<a name="l00341"></a>00341   <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_CKRDY_MASK));
<a name="l00342"></a>00342 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d55486a0d6a70c24b71daaabee51e551"></a><!-- doxytag: member="pm.h::pm_disable_clk0" ref="d55486a0d6a70c24b71daaabee51e551" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_disable_clk0           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will disable the oscillator 0. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00174">174</a> of file <a class="el" href="a00018.html">pm.c</a>.<div class="fragment"><pre class="fragment"><a name="l00175"></a>00175 {
<a name="l00176"></a>00176   pm-&gt;mcctrl &amp;= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
<a name="l00177"></a>00177 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4b72ef7f6a4157966efd67fedc41babd"></a><!-- doxytag: member="pm.h::pm_disable_clk1" ref="4b72ef7f6a4157966efd67fedc41babd" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_disable_clk1           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will disable the oscillator 1. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00235">235</a> of file <a class="el" href="a00018.html">pm.c</a>.<div class="fragment"><pre class="fragment"><a name="l00236"></a>00236 {
<a name="l00237"></a>00237   pm-&gt;mcctrl &amp;= ~AVR32_PM_MCCTRL_OSC1EN_MASK;
<a name="l00238"></a>00238 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="362f6f7ba31e41788ea867d9271d1411"></a><!-- doxytag: member="pm.h::pm_disable_clk32" ref="362f6f7ba31e41788ea867d9271d1411" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_disable_clk32           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will disable the oscillator 32. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00295">295</a> of file <a class="el" href="a00018.html">pm.c</a>.<div class="fragment"><pre class="fragment"><a name="l00296"></a>00296 {
<a name="l00297"></a>00297   pm-&gt;oscctrl32 &amp;= ~AVR32_PM_OSCCTRL32_OSC32EN_MASK;
<a name="l00298"></a>00298 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5025d406938e948be1a321bb0a3de34e"></a><!-- doxytag: member="pm.h::pm_enable_clk0" ref="5025d406938e948be1a321bb0a3de34e" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk0           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>startup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the oscillator 0 to be used with a startup time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startup</em>&nbsp;</td><td>Clock 0 startup time. Time is expressed in term of RCOsc periods (3-bit value) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00167">167</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00180">pm_enable_clk0_no_wait()</a>, and <a class="el" href="a00018.html#l00193">pm_wait_for_clk0_ready()</a>.
<p>
Referenced by <a class="el" href="a00018.html#l00457">pm_switch_to_osc0()</a>.<div class="fragment"><pre class="fragment"><a name="l00168"></a>00168 {
<a name="l00169"></a>00169   <a class="code" href="a00015.html#b50c60c1a2fcafcbdbc395737bce49ae">pm_enable_clk0_no_wait</a>(pm, startup);
<a name="l00170"></a>00170   <a class="code" href="a00015.html#8d73b00aa88012b6230f2929b4b62c20">pm_wait_for_clk0_ready</a>(pm);
<a name="l00171"></a>00171 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b50c60c1a2fcafcbdbc395737bce49ae"></a><!-- doxytag: member="pm.h::pm_enable_clk0_no_wait" ref="b50c60c1a2fcafcbdbc395737bce49ae" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk0_no_wait           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>startup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the oscillator 0 to be used with no startup time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startup</em>&nbsp;</td><td>Clock 0 startup time. Time is expressed in term of RCOsc periods (3-bit value) but not checked. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00180">180</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00071">u_avr32_pm_oscctrl0_t::oscctrl0</a>, and <a class="el" href="a00018.html#l00072">u_avr32_pm_oscctrl0_t::OSCCTRL0</a>.
<p>
Referenced by <a class="el" href="a00018.html#l00167">pm_enable_clk0()</a>.<div class="fragment"><pre class="fragment"><a name="l00181"></a>00181 {
<a name="l00182"></a>00182   <span class="comment">// Read register</span>
<a name="l00183"></a>00183   <a class="code" href="a00009.html">u_avr32_pm_oscctrl0_t</a> u_avr32_pm_oscctrl0 = {pm-&gt;oscctrl0};
<a name="l00184"></a>00184   <span class="comment">// Modify</span>
<a name="l00185"></a>00185   u_avr32_pm_oscctrl0.<a class="code" href="a00009.html#713bfa7c0044a2fd6355a2e74364527e">OSCCTRL0</a>.startup = startup;
<a name="l00186"></a>00186   <span class="comment">// Write back</span>
<a name="l00187"></a>00187   pm-&gt;oscctrl0 = u_avr32_pm_oscctrl0.<a class="code" href="a00009.html#4f62e39a9298f0aeb8658a61634a4743">oscctrl0</a>;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   pm-&gt;mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
<a name="l00190"></a>00190 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="11e96570c59c9b54e612141bad5c9c6f"></a><!-- doxytag: member="pm.h::pm_enable_clk1" ref="11e96570c59c9b54e612141bad5c9c6f" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk1           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>startup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the oscillator 1 to be used with a startup time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startup</em>&nbsp;</td><td>Clock 1 startup time. Time is expressed in term of RCOsc periods (3-bit value) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00228">228</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00241">pm_enable_clk1_no_wait()</a>, and <a class="el" href="a00018.html#l00254">pm_wait_for_clk1_ready()</a>.<div class="fragment"><pre class="fragment"><a name="l00229"></a>00229 {
<a name="l00230"></a>00230   <a class="code" href="a00015.html#3c97a98610de7191421594f7f2407b71">pm_enable_clk1_no_wait</a>(pm, startup);
<a name="l00231"></a>00231   <a class="code" href="a00015.html#d5ba9c5ac6eddbaa3ae1e2fda64b82f2">pm_wait_for_clk1_ready</a>(pm);
<a name="l00232"></a>00232 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3c97a98610de7191421594f7f2407b71"></a><!-- doxytag: member="pm.h::pm_enable_clk1_no_wait" ref="3c97a98610de7191421594f7f2407b71" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk1_no_wait           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>startup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the oscillator 1 to be used with no startup time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startup</em>&nbsp;</td><td>Clock 1 startup time. Time is expressed in term of RCOsc periods (3-bit value) but not checked. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00241">241</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00077">u_avr32_pm_oscctrl1_t::oscctrl1</a>, and <a class="el" href="a00018.html#l00078">u_avr32_pm_oscctrl1_t::OSCCTRL1</a>.
<p>
Referenced by <a class="el" href="a00018.html#l00228">pm_enable_clk1()</a>.<div class="fragment"><pre class="fragment"><a name="l00242"></a>00242 {
<a name="l00243"></a>00243   <span class="comment">// Read register</span>
<a name="l00244"></a>00244   <a class="code" href="a00010.html">u_avr32_pm_oscctrl1_t</a> u_avr32_pm_oscctrl1 = {pm-&gt;oscctrl1};
<a name="l00245"></a>00245   <span class="comment">// Modify</span>
<a name="l00246"></a>00246   u_avr32_pm_oscctrl1.<a class="code" href="a00010.html#5af10855ba510c0e0a096f3fc6881514">OSCCTRL1</a>.startup = startup;
<a name="l00247"></a>00247   <span class="comment">// Write back</span>
<a name="l00248"></a>00248   pm-&gt;oscctrl1 = u_avr32_pm_oscctrl1.<a class="code" href="a00010.html#b2207b690375a3ca20279166eae2bb50">oscctrl1</a>;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250   pm-&gt;mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
<a name="l00251"></a>00251 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="977a1c67c15cb6590bdd07ffc382be69"></a><!-- doxytag: member="pm.h::pm_enable_clk32" ref="977a1c67c15cb6590bdd07ffc382be69" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk32           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>startup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the oscillator 32 to be used with a startup time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startup</em>&nbsp;</td><td>Clock 32 kHz startup time. Time is expressed in term of RCOsc periods (3-bit value) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00288">288</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00301">pm_enable_clk32_no_wait()</a>, and <a class="el" href="a00018.html#l00313">pm_wait_for_clk32_ready()</a>.<div class="fragment"><pre class="fragment"><a name="l00289"></a>00289 {
<a name="l00290"></a>00290   <a class="code" href="a00015.html#b4b3927822c15f8df87264dc234d2c09">pm_enable_clk32_no_wait</a>(pm, startup);
<a name="l00291"></a>00291   <a class="code" href="a00015.html#9700519e5fc96b6cbb4d4e74d710cf49">pm_wait_for_clk32_ready</a>(pm);
<a name="l00292"></a>00292 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b4b3927822c15f8df87264dc234d2c09"></a><!-- doxytag: member="pm.h::pm_enable_clk32_no_wait" ref="b4b3927822c15f8df87264dc234d2c09" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk32_no_wait           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>startup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the oscillator 32 to be used with no startup time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startup</em>&nbsp;</td><td>Clock 32 kHz startup time. Time is expressed in term of RCOsc periods (3-bit value) but not checked. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00301">301</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00083">u_avr32_pm_oscctrl32_t::oscctrl32</a>, and <a class="el" href="a00018.html#l00084">u_avr32_pm_oscctrl32_t::OSCCTRL32</a>.
<p>
Referenced by <a class="el" href="a00018.html#l00288">pm_enable_clk32()</a>.<div class="fragment"><pre class="fragment"><a name="l00302"></a>00302 {
<a name="l00303"></a>00303   <span class="comment">// Read register</span>
<a name="l00304"></a>00304   <a class="code" href="a00011.html">u_avr32_pm_oscctrl32_t</a> u_avr32_pm_oscctrl32 = {pm-&gt;oscctrl32};
<a name="l00305"></a>00305   <span class="comment">// Modify</span>
<a name="l00306"></a>00306   u_avr32_pm_oscctrl32.<a class="code" href="a00011.html#21e81992e1b1c1ab1606774640a9cab8">OSCCTRL32</a>.osc32en = 1;
<a name="l00307"></a>00307   u_avr32_pm_oscctrl32.<a class="code" href="a00011.html#21e81992e1b1c1ab1606774640a9cab8">OSCCTRL32</a>.startup = startup;
<a name="l00308"></a>00308   <span class="comment">// Write back</span>
<a name="l00309"></a>00309   pm-&gt;oscctrl32 = u_avr32_pm_oscctrl32.<a class="code" href="a00011.html#276ddc4dad28b903995ca5b35609765c">oscctrl32</a>;
<a name="l00310"></a>00310 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="154f6db98bf919e5065c47a9454ea31b"></a><!-- doxytag: member="pm.h::pm_enable_osc0_crystal" ref="154f6db98bf919e5065c47a9454ea31b" args="(volatile avr32_pm_t *pm, unsigned int fosc0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc0_crystal           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>fosc0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the crystal mode of the oscillator 0. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fosc0</em>&nbsp;</td><td>Oscillator 0 crystal frequency (Hz) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00160">160</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00143">pm_set_osc0_mode()</a>.
<p>
Referenced by <a class="el" href="a00018.html#l00457">pm_switch_to_osc0()</a>.<div class="fragment"><pre class="fragment"><a name="l00161"></a>00161 {
<a name="l00162"></a>00162   <a class="code" href="a00015.html#b5723ec18af7e56f910651b0d879dfb8">pm_set_osc0_mode</a>(pm, (fosc0 &lt; 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
<a name="l00163"></a>00163                                            AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
<a name="l00164"></a>00164 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="71457d17efdbadb3f1beddd489b20642"></a><!-- doxytag: member="pm.h::pm_enable_osc0_ext_clock" ref="71457d17efdbadb3f1beddd489b20642" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc0_ext_clock           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the external clock mode of the oscillator 0. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00154">154</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00143">pm_set_osc0_mode()</a>.<div class="fragment"><pre class="fragment"><a name="l00155"></a>00155 {
<a name="l00156"></a>00156   <a class="code" href="a00015.html#b5723ec18af7e56f910651b0d879dfb8">pm_set_osc0_mode</a>(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
<a name="l00157"></a>00157 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="55b91688c1de5c7ba887ae2c2da65c1a"></a><!-- doxytag: member="pm.h::pm_enable_osc1_crystal" ref="55b91688c1de5c7ba887ae2c2da65c1a" args="(volatile avr32_pm_t *pm, unsigned int fosc1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc1_crystal           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>fosc1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the crystal mode of the oscillator 1. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fosc1</em>&nbsp;</td><td>Oscillator 1 crystal frequency (Hz) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00221">221</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00204">pm_set_osc1_mode()</a>.<div class="fragment"><pre class="fragment"><a name="l00222"></a>00222 {
<a name="l00223"></a>00223   <a class="code" href="a00015.html#f56b3168a0fdc3ccf45956af3d08244d">pm_set_osc1_mode</a>(pm, (fosc1 &lt; 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
<a name="l00224"></a>00224                                            AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
<a name="l00225"></a>00225 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ad913774e66e6728567fda276b16d7e5"></a><!-- doxytag: member="pm.h::pm_enable_osc1_ext_clock" ref="ad913774e66e6728567fda276b16d7e5" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc1_ext_clock           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the external clock mode of the oscillator 1. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00215">215</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00204">pm_set_osc1_mode()</a>.<div class="fragment"><pre class="fragment"><a name="l00216"></a>00216 {
<a name="l00217"></a>00217   <a class="code" href="a00015.html#f56b3168a0fdc3ccf45956af3d08244d">pm_set_osc1_mode</a>(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
<a name="l00218"></a>00218 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="afccfc12464e07508a75b0e9f09e125b"></a><!-- doxytag: member="pm.h::pm_enable_osc32_crystal" ref="afccfc12464e07508a75b0e9f09e125b" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc32_crystal           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the crystal mode of the 32-kHz oscillator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00282">282</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00265">pm_set_osc32_mode()</a>.<div class="fragment"><pre class="fragment"><a name="l00283"></a>00283 {
<a name="l00284"></a>00284   <a class="code" href="a00015.html#8214bd2c938726ab76ae6be163a589f7">pm_set_osc32_mode</a>(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
<a name="l00285"></a>00285 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9345492d2ae11c99ef58fdeaa239b86a"></a><!-- doxytag: member="pm.h::pm_enable_osc32_ext_clock" ref="9345492d2ae11c99ef58fdeaa239b86a" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc32_ext_clock           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable the external clock mode of the 32-kHz oscillator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00276">276</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00265">pm_set_osc32_mode()</a>.<div class="fragment"><pre class="fragment"><a name="l00277"></a>00277 {
<a name="l00278"></a>00278   <a class="code" href="a00015.html#8214bd2c938726ab76ae6be163a589f7">pm_set_osc32_mode</a>(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
<a name="l00279"></a>00279 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="219014f9e640b87762b1edccb0f122a8"></a><!-- doxytag: member="pm.h::pm_gc_disable" ref="219014f9e640b87762b1edccb0f122a8" args="(volatile avr32_pm_t *pm, unsigned int gc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_gc_disable           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will disable a generic clock. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gc</em>&nbsp;</td><td>generic clock number (0 for gc0...) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00370">370</a> of file <a class="el" href="a00018.html">pm.c</a>.<div class="fragment"><pre class="fragment"><a name="l00372"></a>00372 {
<a name="l00373"></a>00373   pm-&gt;gcctrl[gc] &amp;= ~AVR32_PM_GCCTRL_CEN_MASK;
<a name="l00374"></a>00374 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f398f0b8b8c3ff5649d3d86d7591f349"></a><!-- doxytag: member="pm.h::pm_gc_enable" ref="f398f0b8b8c3ff5649d3d86d7591f349" args="(volatile avr32_pm_t *pm, unsigned int gc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_gc_enable           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable a generic clock. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gc</em>&nbsp;</td><td>generic clock number (0 for gc0...) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00363">363</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
Referenced by <a class="el" href="a00020.html#l00106">local_start_pll0()</a>.<div class="fragment"><pre class="fragment"><a name="l00365"></a>00365 {
<a name="l00366"></a>00366   pm-&gt;gcctrl[gc] |= AVR32_PM_GCCTRL_CEN_MASK;
<a name="l00367"></a>00367 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="18f43cfefefcc5ef47b1d6b7318184ea"></a><!-- doxytag: member="pm.h::pm_gc_setup" ref="18f43cfefefcc5ef47b1d6b7318184ea" args="(volatile avr32_pm_t *pm, unsigned int gc, unsigned int osc_or_pll, unsigned int pll_osc, unsigned int diven, unsigned int div)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_gc_setup           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>osc_or_pll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pll_osc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>diven</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>div</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will setup a generic clock. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gc</em>&nbsp;</td><td>generic clock number (0 for gc0...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>osc_or_pll</em>&nbsp;</td><td>Use OSC (=0) or PLL (=1) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pll_osc</em>&nbsp;</td><td>Select Osc0/PLL0 or Osc1/PLL1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>diven</em>&nbsp;</td><td>Generic clock divisor enable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>div</em>&nbsp;</td><td>Generic clock divisor </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00345">345</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00107">u_avr32_pm_gcctrl_t::gcctrl</a>, and <a class="el" href="a00018.html#l00108">u_avr32_pm_gcctrl_t::GCCTRL</a>.
<p>
Referenced by <a class="el" href="a00020.html#l00106">local_start_pll0()</a>.<div class="fragment"><pre class="fragment"><a name="l00351"></a>00351 {
<a name="l00352"></a>00352   <a class="code" href="a00004.html">u_avr32_pm_gcctrl_t</a> u_avr32_pm_gcctrl = {0};
<a name="l00353"></a>00353 
<a name="l00354"></a>00354   u_avr32_pm_gcctrl.<a class="code" href="a00004.html#8568b8c9cb67b2f0a753ade763d9a663">GCCTRL</a>.oscsel = pll_osc;
<a name="l00355"></a>00355   u_avr32_pm_gcctrl.<a class="code" href="a00004.html#8568b8c9cb67b2f0a753ade763d9a663">GCCTRL</a>.pllsel = osc_or_pll;
<a name="l00356"></a>00356   u_avr32_pm_gcctrl.<a class="code" href="a00004.html#8568b8c9cb67b2f0a753ade763d9a663">GCCTRL</a>.diven  = diven;
<a name="l00357"></a>00357   u_avr32_pm_gcctrl.<a class="code" href="a00004.html#8568b8c9cb67b2f0a753ade763d9a663">GCCTRL</a>.div    = div;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   pm-&gt;gcctrl[gc] = u_avr32_pm_gcctrl.<a class="code" href="a00004.html#032b2be50493be8b25f047fe55d21e9e">gcctrl</a>;
<a name="l00360"></a>00360 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="950f26885a5ac10270176cbe10ab68d5"></a><!-- doxytag: member="pm.h::pm_get_reset_cause" ref="950f26885a5ac10270176cbe10ab68d5" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__inline__ unsigned int pm_get_reset_cause           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the MCU reset cause. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager instance (i.e. &amp;AVR32_PM).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The MCU reset cause which can be masked with the <code>AVR32_PM_RCAUSE_x_MASK</code> bit-masks to isolate specific causes. </dd></dl>

<p>
Definition at line <a class="el" href="a00019.html#l00075">75</a> of file <a class="el" href="a00019.html">pm.h</a>.<div class="fragment"><pre class="fragment"><a name="l00076"></a>00076 {
<a name="l00077"></a>00077   <span class="keywordflow">return</span> pm-&gt;rcause;
<a name="l00078"></a>00078 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e403f725dd02b4a0edabf8c5f4069abf"></a><!-- doxytag: member="pm.h::pm_pll_disable" ref="e403f725dd02b4a0edabf8c5f4069abf" args="(volatile avr32_pm_t *pm, unsigned int pll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_pll_disable           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pll</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will disable a PLL. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pll</em>&nbsp;</td><td>PLL number(0 for PLL0, 1 for PLL1) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00421">421</a> of file <a class="el" href="a00018.html">pm.c</a>.<div class="fragment"><pre class="fragment"><a name="l00423"></a>00423 {
<a name="l00424"></a>00424   pm-&gt;pll[pll] &amp;= ~AVR32_PM_PLLEN_MASK;
<a name="l00425"></a>00425 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8a475c167a147ef710e63eb7074febc5"></a><!-- doxytag: member="pm.h::pm_pll_enable" ref="8a475c167a147ef710e63eb7074febc5" args="(volatile avr32_pm_t *pm, unsigned int pll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_pll_enable           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pll</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable a PLL. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pll</em>&nbsp;</td><td>PLL number(0 for PLL0, 1 for PLL1) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00414">414</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
Referenced by <a class="el" href="a00020.html#l00106">local_start_pll0()</a>.<div class="fragment"><pre class="fragment"><a name="l00416"></a>00416 {
<a name="l00417"></a>00417   pm-&gt;pll[pll] |= AVR32_PM_PLLEN_MASK;
<a name="l00418"></a>00418 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dd1529c5261abd21d936126ca87fc804"></a><!-- doxytag: member="pm.h::pm_pll_get_option" ref="dd1529c5261abd21d936126ca87fc804" args="(volatile avr32_pm_t *pm, unsigned int pll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pm_pll_get_option           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pll</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will get a PLL option. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pll</em>&nbsp;</td><td>PLL number(0 for PLL0, 1 for PLL1) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Option </dd></dl>

<p>
Definition at line <a class="el" href="a00018.html#l00407">407</a> of file <a class="el" href="a00018.html">pm.c</a>.<div class="fragment"><pre class="fragment"><a name="l00409"></a>00409 {
<a name="l00410"></a>00410   <span class="keywordflow">return</span> (pm-&gt;pll[pll] &amp; AVR32_PM_PLLOPT_MASK) &gt;&gt; AVR32_PM_PLLOPT_OFFSET;
<a name="l00411"></a>00411 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e3c68fa61aae34b1b4e064f2efd19ab8"></a><!-- doxytag: member="pm.h::pm_pll_set_option" ref="e3c68fa61aae34b1b4e064f2efd19ab8" args="(volatile avr32_pm_t *pm, unsigned int pll, unsigned int pll_freq, unsigned int pll_div2, unsigned int pll_wbwdisable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_pll_set_option           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pll_freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pll_div2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pll_wbwdisable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will set a PLL option. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pll</em>&nbsp;</td><td>PLL number(0 for PLL0, 1 for PLL1) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pll_freq</em>&nbsp;</td><td>Set to 1 for VCO frequency range 80-180MHz, set to 0 for VCO frequency range 160-240Mhz. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pll_div2</em>&nbsp;</td><td>Divide the PLL output frequency by 2 (this settings does not change the FVCO value) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pll_wbwdisable</em>&nbsp;</td><td>1 Disable the Wide-Bandith Mode (Wide-Bandwith mode allow a faster startup time and out-of-lock time). 0 to enable the Wide-Bandith Mode. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00395">395</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00065">u_avr32_pm_pll_t::pll</a>, and <a class="el" href="a00018.html#l00066">u_avr32_pm_pll_t::PLL</a>.
<p>
Referenced by <a class="el" href="a00020.html#l00106">local_start_pll0()</a>.<div class="fragment"><pre class="fragment"><a name="l00400"></a>00400 {
<a name="l00401"></a>00401   <a class="code" href="a00012.html">u_avr32_pm_pll_t</a> u_avr32_pm_pll = {pm-&gt;pll[pll]};
<a name="l00402"></a>00402   u_avr32_pm_pll.<a class="code" href="a00012.html#df1d0d76771d8aa85d43d569c213466a">PLL</a>.pllopt = pll_freq | (pll_div2 &lt;&lt; 1) | (pll_wbwdisable &lt;&lt; 2);
<a name="l00403"></a>00403   pm-&gt;pll[pll] = u_avr32_pm_pll.<a class="code" href="a00012.html#41e989612d3f42b113e3054ecf739703">pll</a>;
<a name="l00404"></a>00404 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="356dd97babbdf250ea51ccaa84992cf9"></a><!-- doxytag: member="pm.h::pm_pll_setup" ref="356dd97babbdf250ea51ccaa84992cf9" args="(volatile avr32_pm_t *pm, unsigned int pll, unsigned int mul, unsigned int div, unsigned int osc, unsigned int lockcount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_pll_setup           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>osc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>lockcount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will setup a PLL. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pll</em>&nbsp;</td><td>PLL number(0 for PLL0, 1 for PLL1) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mul</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>div</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>osc</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lockcount</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00377">377</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00065">u_avr32_pm_pll_t::pll</a>, and <a class="el" href="a00018.html#l00066">u_avr32_pm_pll_t::PLL</a>.
<p>
Referenced by <a class="el" href="a00020.html#l00106">local_start_pll0()</a>.<div class="fragment"><pre class="fragment"><a name="l00383"></a>00383 {
<a name="l00384"></a>00384   <a class="code" href="a00012.html">u_avr32_pm_pll_t</a> u_avr32_pm_pll = {0};
<a name="l00385"></a>00385 
<a name="l00386"></a>00386   u_avr32_pm_pll.<a class="code" href="a00012.html#df1d0d76771d8aa85d43d569c213466a">PLL</a>.pllosc   = osc;
<a name="l00387"></a>00387   u_avr32_pm_pll.<a class="code" href="a00012.html#df1d0d76771d8aa85d43d569c213466a">PLL</a>.plldiv   = div;
<a name="l00388"></a>00388   u_avr32_pm_pll.<a class="code" href="a00012.html#df1d0d76771d8aa85d43d569c213466a">PLL</a>.pllmul   = mul;
<a name="l00389"></a>00389   u_avr32_pm_pll.<a class="code" href="a00012.html#df1d0d76771d8aa85d43d569c213466a">PLL</a>.pllcount = lockcount;
<a name="l00390"></a>00390 
<a name="l00391"></a>00391   pm-&gt;pll[pll] = u_avr32_pm_pll.<a class="code" href="a00012.html#41e989612d3f42b113e3054ecf739703">pll</a>;
<a name="l00392"></a>00392 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ff34f78cd2e886452e22b0dd81f80fee"></a><!-- doxytag: member="pm.h::pm_switch_to_clock" ref="ff34f78cd2e886452e22b0dd81f80fee" args="(volatile avr32_pm_t *pm, unsigned long clock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_switch_to_clock           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>clock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will switch the power manager main clock. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clock</em>&nbsp;</td><td>Clock to be switched on. AVR32_PM_MCSEL_SLOW for RCOsc, AVR32_PM_MCSEL_OSC0 for Osc0, AVR32_PM_MCSEL_PLL0 for PLL0. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00446">446</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00053">u_avr32_pm_mcctrl_t::mcctrl</a>, and <a class="el" href="a00018.html#l00054">u_avr32_pm_mcctrl_t::MCCTRL</a>.
<p>
Referenced by <a class="el" href="a00020.html#l00106">local_start_pll0()</a>, and <a class="el" href="a00018.html#l00457">pm_switch_to_osc0()</a>.<div class="fragment"><pre class="fragment"><a name="l00447"></a>00447 {
<a name="l00448"></a>00448   <span class="comment">// Read</span>
<a name="l00449"></a>00449   <a class="code" href="a00008.html">u_avr32_pm_mcctrl_t</a> u_avr32_pm_mcctrl = {pm-&gt;mcctrl};
<a name="l00450"></a>00450   <span class="comment">// Modify</span>
<a name="l00451"></a>00451   u_avr32_pm_mcctrl.<a class="code" href="a00008.html#e3b7804f48c339acfa160866d4e0268e">MCCTRL</a>.mcsel = clock;
<a name="l00452"></a>00452   <span class="comment">// Write back</span>
<a name="l00453"></a>00453   pm-&gt;mcctrl = u_avr32_pm_mcctrl.<a class="code" href="a00008.html#758f7f94d5d72657b43364e3abea68dd">mcctrl</a>;
<a name="l00454"></a>00454 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3248d4f14f43849e01bca054da9fdb1e"></a><!-- doxytag: member="pm.h::pm_switch_to_osc0" ref="3248d4f14f43849e01bca054da9fdb1e" args="(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_switch_to_osc0           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>fosc0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>startup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Switch main clock to clock Osc0 (crystal mode). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fosc0</em>&nbsp;</td><td>Oscillator 0 crystal frequency (Hz) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startup</em>&nbsp;</td><td>Crystal 0 startup time. Time is expressed in term of RCOsc periods (3-bit value) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00457">457</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
References <a class="el" href="a00018.html#l00167">pm_enable_clk0()</a>, <a class="el" href="a00018.html#l00160">pm_enable_osc0_crystal()</a>, and <a class="el" href="a00018.html#l00446">pm_switch_to_clock()</a>.
<p>
Referenced by <a class="el" href="a00020.html#l00106">local_start_pll0()</a>.<div class="fragment"><pre class="fragment"><a name="l00458"></a>00458 {
<a name="l00459"></a>00459   <a class="code" href="a00015.html#154f6db98bf919e5065c47a9454ea31b">pm_enable_osc0_crystal</a>(pm, fosc0);            <span class="comment">// Enable the Osc0 in crystal mode</span>
<a name="l00460"></a>00460   <a class="code" href="a00015.html#5025d406938e948be1a321bb0a3de34e">pm_enable_clk0</a>(pm, startup);                  <span class="comment">// Crystal startup time - This parameter is critical and depends on the characteristics of the crystal</span>
<a name="l00461"></a>00461   <a class="code" href="a00015.html#ff34f78cd2e886452e22b0dd81f80fee">pm_switch_to_clock</a>(pm, AVR32_PM_MCSEL_OSC0);  <span class="comment">// Then switch main clock to Osc0</span>
<a name="l00462"></a>00462 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8d73b00aa88012b6230f2929b4b62c20"></a><!-- doxytag: member="pm.h::pm_wait_for_clk0_ready" ref="8d73b00aa88012b6230f2929b4b62c20" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_wait_for_clk0_ready           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will wait until the Osc0 clock is ready. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00193">193</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
Referenced by <a class="el" href="a00018.html#l00167">pm_enable_clk0()</a>.<div class="fragment"><pre class="fragment"><a name="l00194"></a>00194 {
<a name="l00195"></a>00195   <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC0RDY_MASK));
<a name="l00196"></a>00196 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d5ba9c5ac6eddbaa3ae1e2fda64b82f2"></a><!-- doxytag: member="pm.h::pm_wait_for_clk1_ready" ref="d5ba9c5ac6eddbaa3ae1e2fda64b82f2" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_wait_for_clk1_ready           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will wait until the Osc1 clock is ready. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00254">254</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
Referenced by <a class="el" href="a00018.html#l00228">pm_enable_clk1()</a>.<div class="fragment"><pre class="fragment"><a name="l00255"></a>00255 {
<a name="l00256"></a>00256   <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC1RDY_MASK));
<a name="l00257"></a>00257 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9700519e5fc96b6cbb4d4e74d710cf49"></a><!-- doxytag: member="pm.h::pm_wait_for_clk32_ready" ref="9700519e5fc96b6cbb4d4e74d710cf49" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_wait_for_clk32_ready           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will wait until the osc32 clock is ready. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00313">313</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
Referenced by <a class="el" href="a00018.html#l00288">pm_enable_clk32()</a>.<div class="fragment"><pre class="fragment"><a name="l00314"></a>00314 {
<a name="l00315"></a>00315   <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC32RDY_MASK));
<a name="l00316"></a>00316 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5cd1af7daf6f927465ce522b29265225"></a><!-- doxytag: member="pm.h::pm_wait_for_pll0_locked" ref="5cd1af7daf6f927465ce522b29265225" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_wait_for_pll0_locked           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will wait for PLL0 locked. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00428">428</a> of file <a class="el" href="a00018.html">pm.c</a>.
<p>
Referenced by <a class="el" href="a00020.html#l00106">local_start_pll0()</a>.<div class="fragment"><pre class="fragment"><a name="l00429"></a>00429 {
<a name="l00430"></a>00430   <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_LOCK0_MASK));
<a name="l00431"></a>00431 
<a name="l00432"></a>00432   <span class="comment">// Bypass the lock signal of the PLL</span>
<a name="l00433"></a>00433   pm-&gt;pll[0] |= AVR32_PM_PLL0_PLLBPL_MASK;
<a name="l00434"></a>00434 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9ae711c886d0b25bdb52e829975a6d6e"></a><!-- doxytag: member="pm.h::pm_wait_for_pll1_locked" ref="9ae711c886d0b25bdb52e829975a6d6e" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_wait_for_pll1_locked           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&nbsp;</td>
          <td class="paramname"> <em>pm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will wait for PLL1 locked. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pm</em>&nbsp;</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00018.html#l00437">437</a> of file <a class="el" href="a00018.html">pm.c</a>.<div class="fragment"><pre class="fragment"><a name="l00438"></a>00438 {
<a name="l00439"></a>00439   <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_LOCK1_MASK));
<a name="l00440"></a>00440 
<a name="l00441"></a>00441   <span class="comment">// Bypass the lock signal of the PLL</span>
<a name="l00442"></a>00442   pm-&gt;pll[1] |= AVR32_PM_PLL1_PLLBPL_MASK;
<a name="l00443"></a>00443 }
</pre></div>
<p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Sep 20 12:12:50 2007 for AVR32 UC3 - Power Manager Driver Example 2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
